<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="http://localhost:4000/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-02-17T09:30:42-05:00</updated><id>http://localhost:4000//</id><title type="html">Blog</title><subtitle>Projects by Olivia Walch</subtitle><entry><title type="html">Simple Triangulation</title><link href="http://localhost:4000/Triangulate/" rel="alternate" type="text/html" title="Simple Triangulation" /><published>2017-02-17T00:00:00-05:00</published><updated>2017-02-17T00:00:00-05:00</updated><id>http://localhost:4000/Triangulate</id><content type="html" xml:base="http://localhost:4000/Triangulate/">&lt;p&gt;I wrote a quick and low-key Matlab script a while ago to triangulate images through the magic of Delaunay Triangulation and corner detection. The code is available &lt;a href=&quot;https://github.com/ojwalch/triangulate-svg&quot;&gt;here&lt;/a&gt;, and running it both plots the result in Matlab and saves it to an SVG file. Check out a few demos below!&lt;/p&gt;

&lt;ul class=&quot;gallery&quot;&gt;


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    
    &lt;li&gt;
      &lt;a href=&quot;/assets/triangulate/astro_output.png&quot;&gt;
        &lt;img src=&quot;/assets/triangulate/astro_output.png&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;

    


    
    &lt;li&gt;
      &lt;a href=&quot;/assets/triangulate/emmy_output.png&quot;&gt;
        &lt;img src=&quot;/assets/triangulate/emmy_output.png&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;

    


    
    &lt;li&gt;
      &lt;a href=&quot;/assets/triangulate/mlktri.png&quot;&gt;
        &lt;img src=&quot;/assets/triangulate/mlktri.png&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;

    


    
    &lt;li&gt;
      &lt;a href=&quot;/assets/triangulate/rooster.png&quot;&gt;
        &lt;img src=&quot;/assets/triangulate/rooster.png&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;

    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    

&lt;/ul&gt;</content><summary type="html">I wrote a quick and low-key Matlab script a while ago to triangulate images through the magic of Delaunay Triangulation and corner detection. The code is available here, and running it both plots the result in Matlab and saves it to an SVG file. Check out a few demos below!</summary></entry><entry><title type="html">Cool warps</title><link href="http://localhost:4000/Cool-Warps/" rel="alternate" type="text/html" title="Cool warps" /><published>2017-02-16T00:00:00-05:00</published><updated>2017-02-16T00:00:00-05:00</updated><id>http://localhost:4000/Cool-Warps</id><content type="html" xml:base="http://localhost:4000/Cool-Warps/">&lt;p&gt;When I was first learning complex analysis, I thought conformal mappings were too cool not to mess around with. In doing so, I ended up writing code to make some sweet conformal mapping art, as well as some sick warping GIFs. The Matlab code to make the GIFs is on &lt;a href=&quot;https://github.com/ojwalch/cool-warps&quot;&gt;my GitHub page&lt;/a&gt;, and some sample outputs are below.&lt;/p&gt;

&lt;p&gt;But first, a little more detail:&lt;/p&gt;

&lt;p&gt;Conformal mappings are mappings that preserve angles locally. If I map an image in a conformal way, then if you zoom in enough on a spot in the output, it will eventually look like a zoomed in version of the original (albeit likely rotated). This code generates warping GIFs by interpolating between (i.e. blending) conformal mappings of the complex plane.&lt;/p&gt;

&lt;p&gt;In all of the following, I assume that I tile the complex plane with the given image. Then I iterate over all the pixels in the output to assign a value to each one. The values come from mapping the pixel positions in the output by the inverse function of the conformal map we’re trying to achieve and then modding by the dimensions of the image (hence, the tiling assumption).&lt;/p&gt;

&lt;p&gt;For each GIF, I randomly generate an order for my pre-coded set of mappings, which should be conformal in the first quadrant. Then I interpolate from one to the next to create the cool space zoom effects; this often, but not always, preserves the assumption that things will be conformal, so it’s fun to look out for points in the GIFs where the map’s no longer conformal and the outputs look weird.&lt;/p&gt;

&lt;ul class=&quot;gallery&quot;&gt;


    


    


    
    &lt;li&gt;
      &lt;a href=&quot;/assets/conformal/broccoli_output.png&quot;&gt;
        &lt;img src=&quot;/assets/conformal/broccoli_output.png&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;

    


    
    &lt;li&gt;
      &lt;a href=&quot;/assets/conformal/conformal1.png&quot;&gt;
        &lt;img src=&quot;/assets/conformal/conformal1.png&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;

    


    
    &lt;li&gt;
      &lt;a href=&quot;/assets/conformal/galaxy_output.gif&quot;&gt;
        &lt;img src=&quot;/assets/conformal/galaxy_output.gif&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;

    


    
    &lt;li&gt;
      &lt;a href=&quot;/assets/conformal/head_output.gif&quot;&gt;
        &lt;img src=&quot;/assets/conformal/head_output.gif&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;

    


    
    &lt;li&gt;
      &lt;a href=&quot;/assets/conformal/khanformal.png&quot;&gt;
        &lt;img src=&quot;/assets/conformal/khanformal.png&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;

    


    
    &lt;li&gt;
      &lt;a href=&quot;/assets/conformal/nancy_output.gif&quot;&gt;
        &lt;img src=&quot;/assets/conformal/nancy_output.gif&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;

    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    

&lt;/ul&gt;</content><summary type="html">When I was first learning complex analysis, I thought conformal mappings were too cool not to mess around with. In doing so, I ended up writing code to make some sweet conformal mapping art, as well as some sick warping GIFs. The Matlab code to make the GIFs is on my GitHub page, and some sample outputs are below.</summary></entry><entry><title type="html">Squigglish!</title><link href="http://localhost:4000/Squigglish/" rel="alternate" type="text/html" title="Squigglish!" /><published>2017-02-15T00:00:00-05:00</published><updated>2017-02-15T00:00:00-05:00</updated><id>http://localhost:4000/Squigglish</id><content type="html" xml:base="http://localhost:4000/Squigglish/">&lt;p&gt;&lt;a href=&quot;https://itunes.apple.com/us/app/squigglish!/id1200924640?mt=8&quot;&gt;Squigglish!&lt;/a&gt; is an iOS drawing app that makes the lines you draw wiggle. You can draw on a solid color canvas or on photos, and your creations can be exported to movies or GIFs. Like other projects of mine with &lt;a href=&quot;http://www-personal.umich.edu/~majaco/&quot;&gt;Matt&lt;/a&gt;, it’s powered by the magic of Fourier series. You can download the app &lt;a href=&quot;https://itunes.apple.com/us/app/squigglish!/id1200924640?mt=8&quot;&gt;here&lt;/a&gt;, and look below for some sample outputs. I’ll be updating this gallery with some of my favorite Squigglish creations, and anyone who’s interested should feel encouraged to submit their faves!&lt;/p&gt;

&lt;ul class=&quot;gallery&quot;&gt;


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    
    &lt;li&gt;
      &lt;a href=&quot;/assets/squigglish/demo1.GIF&quot;&gt;
        &lt;img src=&quot;/assets/squigglish/demo1.GIF&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;

    


    
    &lt;li&gt;
      &lt;a href=&quot;/assets/squigglish/demo2.GIF&quot;&gt;
        &lt;img src=&quot;/assets/squigglish/demo2.GIF&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;

    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    

&lt;/ul&gt;</content><summary type="html">Squigglish! is an iOS drawing app that makes the lines you draw wiggle. You can draw on a solid color canvas or on photos, and your creations can be exported to movies or GIFs. Like other projects of mine with Matt, it’s powered by the magic of Fourier series. You can download the app here, and look below for some sample outputs. I’ll be updating this gallery with some of my favorite Squigglish creations, and anyone who’s interested should feel encouraged to submit their faves!</summary></entry><entry><title type="html">ActiveReader</title><link href="http://localhost:4000/ActiveReader/" rel="alternate" type="text/html" title="ActiveReader" /><published>2017-02-14T00:00:00-05:00</published><updated>2017-02-14T00:00:00-05:00</updated><id>http://localhost:4000/ActiveReader</id><content type="html" xml:base="http://localhost:4000/ActiveReader/">&lt;p&gt;I have a terrible time learning and retaining content from reading articles or textbooks, so I wrote a little bit of code to take a block of text and turn it into a multiple choice quiz by removing one word from every sentence. It’s called &lt;a href=&quot;http://www.oliviawalch.com/active-reader&quot;&gt;ActiveReader&lt;/a&gt;, and the code behind it is &lt;a href=&quot;https://github.com/ojwalch/active-reader&quot;&gt;available on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;See the screenshots below for a glimpse of it in action, or try it yourself &lt;a href=&quot;http://www.oliviawalch.com/active-reader&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/active-reader/screenshot1.png&quot; alt=&quot;Screenshot 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/active-reader/screenshot2.png&quot; alt=&quot;Screenshot 2&quot; /&gt;&lt;/p&gt;</content><summary type="html">I have a terrible time learning and retaining content from reading articles or textbooks, so I wrote a little bit of code to take a block of text and turn it into a multiple choice quiz by removing one word from every sentence. It’s called ActiveReader, and the code behind it is available on GitHub.</summary></entry><entry><title type="html">Picture Clouds</title><link href="http://localhost:4000/Picture-Clouds/" rel="alternate" type="text/html" title="Picture Clouds" /><published>2017-02-13T00:00:00-05:00</published><updated>2017-02-13T00:00:00-05:00</updated><id>http://localhost:4000/Picture-Clouds</id><content type="html" xml:base="http://localhost:4000/Picture-Clouds/">&lt;p&gt;I’ve always loved how word clouds look, so I wrote up a MATLAB implementation for images. Like the Wordle algorithm &lt;a href=&quot;http://stackoverflow.com/questions/342687/algorithm-to-implement-a-word-cloud-like-wordle&quot;&gt;described here&lt;/a&gt;, the code spirals out from a point on a canvas until it finds a point to place the image where no intersection occurs. Code and a few sample images are on &lt;a href=&quot;https://github.com/ojwalch/picture-clouds&quot;&gt;my GitHub page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A few more sample outputs are below; image themes include: Audrey Hepburn, Eartha Kitt, Agatha Christie, Virginia Woolf, The Canterbury Tales, and &lt;a href=&quot;https://en.wikipedia.org/wiki/Ernie_Bushmiller&quot;&gt;my beloved Nancy&lt;/a&gt;.&lt;/p&gt;

&lt;ul class=&quot;gallery&quot;&gt;


    


    


    


    


    


    


    


    


    
    &lt;li&gt;
      &lt;a href=&quot;/assets/picture-clouds/agatha_example.png&quot;&gt;
        &lt;img src=&quot;/assets/picture-clouds/agatha_example.png&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;

    


    
    &lt;li&gt;
      &lt;a href=&quot;/assets/picture-clouds/audrey_example.png&quot;&gt;
        &lt;img src=&quot;/assets/picture-clouds/audrey_example.png&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;

    


    
    &lt;li&gt;
      &lt;a href=&quot;/assets/picture-clouds/canterbury_example.png&quot;&gt;
        &lt;img src=&quot;/assets/picture-clouds/canterbury_example.png&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;

    


    
    &lt;li&gt;
      &lt;a href=&quot;/assets/picture-clouds/complex_example.png&quot;&gt;
        &lt;img src=&quot;/assets/picture-clouds/complex_example.png&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;

    


    
    &lt;li&gt;
      &lt;a href=&quot;/assets/picture-clouds/complex_example_2.png&quot;&gt;
        &lt;img src=&quot;/assets/picture-clouds/complex_example_2.png&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;

    


    
    &lt;li&gt;
      &lt;a href=&quot;/assets/picture-clouds/eartha_example.png&quot;&gt;
        &lt;img src=&quot;/assets/picture-clouds/eartha_example.png&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;

    


    
    &lt;li&gt;
      &lt;a href=&quot;/assets/picture-clouds/nancy_example.png&quot;&gt;
        &lt;img src=&quot;/assets/picture-clouds/nancy_example.png&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;

    


    
    &lt;li&gt;
      &lt;a href=&quot;/assets/picture-clouds/nancy_example_2.png&quot;&gt;
        &lt;img src=&quot;/assets/picture-clouds/nancy_example_2.png&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;

    


    
    &lt;li&gt;
      &lt;a href=&quot;/assets/picture-clouds/woolf_example.png&quot;&gt;
        &lt;img src=&quot;/assets/picture-clouds/woolf_example.png&quot; /&gt;
      &lt;/a&gt;
    &lt;/li&gt;

    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    


    

&lt;/ul&gt;</content><summary type="html">I’ve always loved how word clouds look, so I wrote up a MATLAB implementation for images. Like the Wordle algorithm described here, the code spirals out from a point on a canvas until it finds a point to place the image where no intersection occurs. Code and a few sample images are on my GitHub page.</summary></entry></feed>
